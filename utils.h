#ifndef UNTILS_H
#define UNTILS_H


 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// VoidPtrToUINT64
///
/// @brief
///
/// @param
///
/// @return
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include<string.h>
#include <fcntl.h>
#include <utils/Log.h> 
#include <unistd.h>
#include <errno.h>
#include "utils.h"
#include "types.h"


#define NEW new(MemFlagsNone, MemTypeAny, NULL, 0)
#define DELETE delete

typedef INT32             MemFlags;
static const MemFlags MemFlagsNone            =  0x00;   ///< No flags

typedef INT32                   MemType;
static const MemType    MemTypeAny      = 0;
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// StrError
///
/// @brief get linux error
///
/// @param  see
///
/// @return None
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 VOID StrError(
 CHAR*   pErrorMsg,
 SIZE_T  errorMsgSize,
 INT     errorNum);

 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// VoidPtrToUINT64
///
/// @brief prtToUNINT64
///
/// @param  see
///
/// @return None
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline  UINT64 VoidPtrToUINT64(void* pVoid)
{
    return static_cast<UINT64>(reinterpret_cast<SIZE_T>(pVoid));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// VSNPrintf
///
/// @brief
///
/// @param
///
/// @return
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline INT VSNPrintf(
    CHAR*       pDst,
    SIZE_T      sizeDst,
    const CHAR* pFormat,
    va_list     argptr
)
{
    INT numCharWritten = 0;
    numCharWritten = vsnprintf(pDst, sizeDst, pFormat, argptr);
    return numCharWritten;
}
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// SNPrintF
///
/// @brief prtToUNINT64
///
/// @param  see
///
/// @return None
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline INT SNPrintF(
    CHAR* pDst,
    SIZE_T sizeDst,
    const CHAR* pFormat,
    ...
)
{
    INT numCHARWriten;
    va_list args;
    va_start (args, pFormat);
    numCHARWriten  = VSNPrintf(pDst, sizeDst, pFormat, args);
    va_end(args);
    return numCHARWriten;
}
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// memcpy
///
/// @brief prtToUNINT64
///
/// @param  see
///
/// @return None
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline VOID* MemCpy(
    VOID*   pDst,
    const VOID* pSrc,
    SIZE_T  numBytes)
{
    VOID* pData = NULL;
    if((NULL != pDst) && (NULL != pSrc))
    {
        pData = memcpy(pDst, pSrc, numBytes);
    }
    return pData;
}

// class Mutex final
// {
//     public:
//     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//     /// Create
//     ///
//     /// @brief 两个ioctl包装
//     /// @param  see
//     ///
//     /// @return None
//     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//     Static Mutex* Create(
//         const CHAR* pResourceName);
    
//     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//     /// Destory
//     ///
//     /// @brief 
//     /// @param  see
//     ///
//     /// @return None
//     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//     VOID Destory();
    
//     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//     /// LOCK
//     ///
//     /// @brief 
//     /// @param  see
//     ///
//     /// @return None
//     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//     VOID Lock();

//     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//     /// UnLOCK
//     ///
//     /// @brief 
//     /// @param  see
//     ///
//     /// @return None
//     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//     VOID Unlock();
//     static const SIZE_T MaxResourceNameSize = 128;              ///< Max length of resource name


//     private:
//     Mutex() = deafult;

//     ~Mutex() = deafult;

//     Result Initialize(
//         const CHAR* presourceName);
//     Mutex(const Mutex&) = delete;                ///< Disallow the copy constructor
//     Mutex& operator=(const Mutex&) = delete;     ///< Disallow assignment operator
//     pthread_mutex_t     m_mutex;                ///< (Linux) Mutex
//     BOOL                m_validMutex;           ///< (Linux) Indicates if underlying mutex is valid
//     CHAR m_pResourceName[Mutex::MaxResourceNameSize]
// };


#endif